%% fisher
clc
clear
close all
load fisheriris
scatter(meas(1:50,1), meas(1:50,2), 15, 'r', 'filled')
hold on
scatter(meas(51:100,1), meas(51:100,2), 15, 'g', 'filled')
scatter(meas(101:end,1), meas(101:end,2), 15, 'b', 'filled')
xlabel('Sepal length (cm)');ylabel('Sepal width (cm)')
f = gcf
set(f, 'Position', [100 100 300 240])
a = gca
title('Fisher Iris Dataset');
set(a, 'FontSize', 9)
box on;

%% 生成高斯混合模型
% 声明GMM需要的参数
clc
clear
close all
Mu = [1 2;-3 -5];                    % 均值
Sigma = cat(3,[2 0;0 .5],[1 0;0 1]); % 方差，cat函数将两个矩阵在某个维上进行连接
P = ones(1,2)/2;                     % 混合系数

% 创建GMM模型
gm = gmdistribution(Mu,Sigma,P);   
% 显示GMM的属性
properties = properties(gm)
 
% 图示GMM的PDF
gmPDF = @(x,y)pdf(gm,[x y]); 
 
f = figure
set(f, 'Position', [100 100 800 400]);
p1 = subplot(121);
ezsurf(gmPDF,[-10 10],[-10 10])
title('PDF of the GMM');
set(p1, 'FontSize', 9)
% 图示CDF
gmCDF = @(x,y)cdf(gm,[x y]); 
 
p2 = subplot(122);
ezsurf(@(x,y)cdf(gm,[x y]),[-10 10],[-10 10])
title('CDF of the GMM');
set(p2, 'FontSize', 9)


%% 拟合一个GMM模型
% 产生两个二维的单高斯模型，并用来产生模拟数据
close all
clear
% 第一个高斯
mu1 = [1 2];
Sigma1 = [2 0; 0 0.5];
% 第二个高斯
mu2 = [-3 -5];
Sigma2 = [1 0;0 1];
rng(1); % 为了重复再现
% 根据两个高斯模型，分别随机产生1000个样本点，并组合在一起
X = [mvnrnd(mu1,Sigma1,1000);mvnrnd(mu2,Sigma2,1000)]; 

% 模型拟合，声明2个成分，gm是一个结构体，保存了拟合模型的参数
gm = fitgmdist(X, 2);

% 画出拟合的高斯模型
y = [zeros(1000,1);ones(1000,1)];   % 两类数据的标签
h = gscatter(X(:,1),X(:,2),y);
% set(gca, 'YLim', [-10 10]);
hold on
ezcontour(@(x1,x2)pdf(gm,[x1 x2]),get(gca,{'XLim','YLim'}))
title('{\bf 散点图和拟合的高斯模型轮廓}')
legend(h,'Model-0','Model-1', 'Location', 'SouthEast')
set(gca, 'YLim', [-8 6], 'XLim', [-6 6], 'FontSize', 9);
set(gcf, 'Position', [100 100 400 300]);
hold off

% 打印参数
properties(gm)
gm.mu
gm.Sigma

%% 利用GMM聚类
% 产生数据
clear
close all
rng default;  % For reproducibility
mu1 = [1 2];
sigma1 = [3 .2; .2 2];
mu2 = [-1 -2];
sigma2 = [2 0; 0 1];
%2个高斯的数据样本
X = [mvnrnd(mu1,sigma1,200); mvnrnd(mu2,sigma2,100)]; 
n = size(X,1);
 
scatter(X(1:200,1),X(1:200,2),15,'ro','filled');
hold on; 
scatter(X(201:end,1),X(201:end,2),15,'bo','filled');
set(gcf, 'Position', [100 100 450 360]);
title('仿真数据');
legend('cluster-1', 'cluster-2', 'Location', 'SouthEast');
set(gca, 'FontSize', 10);

% 拟合模型
options = statset('Display','final');
gm = fitgmdist(X,2,'Options',options)
% 画出拟合模型的投影散点图：
hold on
ezcontour(@(x,y)pdf(gm,[x y]),[-6 6],[-6 6]);
title('散点图和拟合GMM模型')
xlabel('x'); ylabel('y');
set(gcf, 'Position', [100 100 450 360]);

% 利用cluster方法聚类
idx = cluster(gm,X);
estimated_label = idx;
ground_truth_label = [ones(200,1); 2*ones(100,1)];
k = find(estimated_label ~= ground_truth_label);
% 标记错误分类的点为数字3
idx(k,1) = 3;

figure;
gscatter(X(:,1),X(:,2),idx);
legend('Cluster 1','Cluster 2','error', 'Location','NorthWest');
title('GMM聚类');
set(gcf, 'Position', [100 100 400 320]);

% 计算后验概率
% p 是n*2矩阵，每一行是一个样本点，每一列代表对于两个类的隶属度大小
P = posterior(gm,X);
% 标记类别
cluster1 = (idx == 1); 
cluster2 = (idx == 2); 
figure;
% 类别1
scatter(X(cluster1,1),X(cluster1,2),15,P(cluster1,1),'+')
hold on
scatter(X(cluster2,1),X(cluster2,2),15,P(cluster2,1),'o')
hold off
clrmap = jet(80);
colormap(clrmap(9:72,:))
ylabel(colorbar,'属于类别1的后验概率')
title('隶属类别1的后验概率')
legend('cluster-1', 'cluster-2')
set(gcf, 'Position', [100 100 400 320]);
box on

%% 预测
% 人工生成75个测试点
Mu = [mu1; mu2]; 
Sigma = cat(3,sigma1,sigma2); 
p = [0.75 0.25]; 
gmTrue = gmdistribution(Mu,Sigma,p);%生成一个高斯混合模型
X0 = random(gmTrue,75);
% 新数据聚类
[idx0,~,P0] = cluster(gm,X0);

figure;
l = ezcontour(@(x,y)pdf(gm,[x y]),[min(X0(:,1)) max(X0(:,1))],...
    [min(X0(:,2)) max(X0(:,2))]);
hold on;
gscatter(X0(:,1),X0(:,2),idx0,'rb','+o');
legend('投影轮廓','Cluster 1','Cluster 2','Location','NorthWest');
title('测试新数据分类效果')
hold off;
set(gcf, 'Position', [100 100 400 320]);
set(l, 'LineWidth', 2);

%% 软聚类的列子  
clear; close all
rng(3)  % For reproducibility
mu1 = [1 2];
sigma1 = [3 .2; .2 2];
mu2 = [-1 -2];
sigma2 = [2 0; 0 1];
% 待聚类的数据
X = [mvnrnd(mu1,sigma1,200); mvnrnd(mu2,sigma2,100)];
 
gm = fitgmdist(X,2);
% 后验概率如果在在[.4, .6]范围内，则人为可以同时
threshold = [0.4 0.6];
% 用posterior函数求样本数据X关于每个成分的后验概率，p是n*k矩阵
P = posterior(gm,X);
% n是样本数，下面对用sort函数对每个类的隶属度大小排序，这里只有两个类
n = size(X,1);
% order返回隶属度值从小到大的对应样本的索引
[~,order] = sort(P(:,1));
figure
subplot(121)
plot(1:n,P(order,1),'r-',1:n,P(order,2),'b-', 'LineWidth', 1.5)
legend({'Cluster 1', 'Cluster 2'})
ylabel('隶属度')
xlabel('样本点')
title('GMM聚类的隶属度曲线')
% 确定同时属于两个类的点
idx = cluster(gm,X);
idxBoth = find(P(:,1)>=threshold(1) & P(:,1)<=threshold(2)); 
% 返回同时属于两个cluster的样本个数
numInBoth = numel(idxBoth)
 
subplot(122)
gscatter(X(:,1),X(:,2),idx,'rb','po',5)
hold on
scatter(X(idxBoth,1),X(idxBoth,2), 30, 'b','filled')
legend({'Cluster 1','Cluster 2','Both Clusters'},'Location','SouthEast', 'FontSize', 8)
title('软聚类')
xlabel('$x$', 'Interpreter', 'Latex')
ylabel('$y$', 'Interpreter', 'Latex')
hold off
set(gcf, 'Position', [100 100 600 260]);


